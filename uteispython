INFOS:
[13:00] <gwidion> lkzone: Os maiores porblemas sao: Threads em Python nao dao ganho de performance a nao ser que as tarefas tenham gargalos de I/O (rede inclusa) - -e quando voce tem que sincornizar dados.
[13:09] <gwidion> cobrinha exec import sys; import time; from threading import Thread; X = type("bla", (Thread,), {"run": lambda s: [sys.stdout.write(  str((time.sleep(.2),i )[1])+"\n")  for i in range(10) ]});[X().start() for _ in range(5)]
[13:11] <gwidion> sim - um dos jeitos de fazer é cria ruma subclasse de Thread,e sobre-escrever o método "run"
[13:12] <gwidion> (é isso que eu faço acima, mas pra ficar numa linha usei a chamad aa "type" em vez da keyword "class" )
[13:14] <gwidion> por que se precisar de um projtosolido que iria se beneficiar de execução concorrente, o negocio é usar ou um frameword de execuçaõ assincrona, ou execução em multiplos processos.
[13:17] <gwidion> se voce vai precisar de uma unica thread separada para executar uma função, nao precisa faze ruma subclasse de Thread
[13:17] <gwidion> voce instancia a Thread e fala que o atributo "target" dela é a função que voce quer executar, sem parametros
[13:17] <gwidion> e ai faz o start()
import sys
import time
from threading import Thread

class X(Thread):
    def run(self):
        for i in range(10):
            time.sleep(.2)
            print i

for j in range(5):
   x = X()
   x.start()

[13:24] <lkzone> o método run é um método obrigatório da Thread?
[13:25] <gwidion> lkzone: nao - como eu disse, o metodo "run"  padrão executa a funçao "target" do objeto, se houver.

wiki do pythonbrasil

if inline
print ("oo" if 1>2 else "ii")

Biblioteca para conexao SSH
>>> import pexpect

Métodos estáticos
class MyClass(object):
    @staticmethod
    def the_static_method(x):
        print x
MyClass.the_static_method(2) # outputs 2

biblioteca para enviar email
>>> import smtplib

Shell code from python
>>> import subprocess
>>> subprocess.call(['./test.sh']) 

Manipulando banco de dados mysql
my = db.connect("localhost","root","","site")
cursor = my.cursor()
cursor.execute("SELECT VERSION()")
try:
    cursor.execute("SELECT * FROM noticias")
    my.commit()
    print cursor.fetchall()[1][2]
except:
    my.rollback()
    print "lol"
my.close()

Colocar outro nome em uma classe importada
ex: import MySQLdb as db

Testar se uma variavel existe
# Ensure variable is defined
try:
    x
except NameError:
    x = None
# Test whether variable is defined to be None
if x is None:
    some_fallback_operation()
else:
    some_operation(x)

tuplas listas e dicionarios como parametros
ex:
def teste(x):
    print x
L = {'rod' : 'road' , 1 : 'gelop' }
teste(L)

self
Somente temos que colocar o self como primeiro parâmetro de um método tipo função. Não precisa se for uma função fora da classe. O self indica o objeto instanciado.

self._private_var
membro privado por convenção

def teste(**dados) e def teste(*dados)
* e ** é uma forma de expansão/contração dos parâmetros
basicamente, se voce cria uma funçao def teste(*args) , pode passar quantos parâmetros quiser , todos eles vão cair na tupla 'args'
com o ** é a mesma coisa só que para parâmetros nomeados (dicionarios)
def teste(**dados): ...
na hora de xamar
teste(nome='lkzone',linguagem='python')
neste caso 'dados' será uma referencia a um dicionario com duas chaves e dois valores . Dados seria {'nome': 'lkzone', 'linguagem':'python'}

__new__() e __init__()
O contrutor é um método especial , chamado __new__(). Após a chamado ao construtor, o método __init__() é chamado

metodos privados
class folks:
    score = 120
    cscore__ = 20


for
for new_var in array_:
    print new_var,"\n"

if and else
if 1 == 1 \
and 2 == 2 \
and 3 == 4:
    print "forbidden"
else:
    print "poker"

todo script python deve começar com os seguintes codigos
#!/usr/bin/env python
# -*- coding: utf-8 -*-

Parenteses no print faz a saida virar uma tupla
ex: print ("oi ", nome , "\n", "eu sou um alse")

.split() e .join()
print 'source,ware'.split(',')
print '+'.join(['source', 'ware'])
Resultado:
['source', 'ware']
source+ware

strip just e center
print "--", 'source'.ljust(10), "--"
print "--", 'source'.rjust(10), "--"
print "--", 'source'.center(10), "--"
print "--", '   source   '.strip(), "--"
print "--", '   source   '.rstrip(), "--"
print "--", '   source   '.lstrip(), "--"
Resultado:
-- source     --
--     source --
--   source   --
-- source --
--    source --
-- source    --

.isalnum() , .isalpha() , .isdigit() , .isspace()
print "'123#abc' só contém letras e números?", '123#abc'.isalnum()
print "'abc' só contém letras?", 'abc'.isalpha()
print "'123' só contém digitos?", '123'.isdigit()
print "'abc ' só contém espaços?", 'abc'.isspace()

.count()
A função “count” conta o número de vezes que uma string ou caractere dado como parâmetro, aparece na string original.
Exemplo:
print "Número de 'r's em 'sourceware':", 'sourceware'.count("r")
Resultado:
Número de 'r's em 'sourceware': 2
Veja mais em Tutorial de Python - Funções para Strings | Sourceware Blog


.str()
>>> numero = 12.45
>>> string = str(numero)
>>> string
'12.45'

.find()
>>>nome = 'python'
>>> nome.find('t')
2

capitalize() retorna a primeira letra de string em maiúscula, mas sem alterar o valor da string atual. Tambem tem o upper(), e o lower()

.partition()
>>> "2.7.0_bf4fda703454".partition('_')
('2.7.0', '_', 'bf4fda703454')

sys.argv[1]
array de argumentos quando passado pela linha de comandos

.replace()
>>> nome = 'mergulhando em java'
>>> nome = nome.replace(' em java', ' no python')
>>> nome
'mergulando no python'

.strip()
>>> nome = '     python e muito bom    '
>>> nome.strip()
'python e muito bom'


